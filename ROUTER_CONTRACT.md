# Контракт Router и NavigationNode

## Обзор

**Router** — это движок навигации, который управляет маршрутизацией и историей переходов в приложении. Router работает **исключительно** с объектами, реализующими интерфейс **NavigationNode**, и делегирует им всю логику определения маршрутов и структуры навигации.

**NavigationStack** и **TabBar** являются конкретными реализациями `NavigationNode` и реализуют механику Router для стековой навигации и таб-бара соответственно.

---

## Архитектура

```
Router (движок)
    ↓ работает только с
NavigationNode (контракт)
    ↓ реализуют
NavigationStack | TabBar | ... (конкретные реализации)
```

### Основные принципы

1. **Router не знает о конкретных реализациях** — он работает только через интерфейс `NavigationNode`
2. **Вся логика маршрутизации определена в NavigationNode** — Router лишь собирает и использует эту информацию
3. **Состояние делегируется NavigationNode** — каждый узел определяет свою структуру маршрутов и дочерние узлы
4. **Router координирует навигацию** — обрабатывает навигационные действия (push, replace, pop) и синхронизирует состояние

---

## Интерфейс NavigationNode

Любой объект, реализующий `NavigationNode`, должен предоставлять следующие методы:

### Обязательные методы

#### `getId(): string`
Возвращает уникальный идентификатор узла. Используется Router для:
- Отслеживания истории по стеку (`stackId`)
- Связывания маршрутов с узлами
- Подписки на изменения истории конкретного стека

**Требования:**
- ID должен быть уникальным в пределах роутера
- ID не должен изменяться в течение жизненного цикла узла

#### `getNodeRoutes(): NodeRoute[]`
Возвращает массив маршрутов, определенных данным узлом.

**Структура NodeRoute:**
```typescript
type NodeRoute = {
  routeId: string;                    // Уникальный ID маршрута
  path: string;                       // Полный путь с query (например, "/auth?kind=email")
  pathnamePattern: string;            // Паттерн пути для матчинга (например, "/auth" или "*")
  isWildcardPath: boolean;            // Является ли путь wildcard ("*")
  queryPattern: QueryPattern | null;  // Паттерн query-параметров
  baseSpecificity: number;            // Специфичность маршрута (для выбора лучшего match)
  matchPath: (path: string) => false | { params: Record<string, any> };  // Функция матчинга пути
  component: React.ComponentType<any>; // React компонент для рендеринга
  controller?: Controller<any, any>;   // Опциональный контроллер для асинхронной логики
  options?: ScreenOptions;            // Опции экрана (header, animation и т.д.)
  childNode?: NavigationNode;         // Опциональный дочерний узел (вложенная навигация)
};
```

**Роль Router:**
- Собирает все маршруты из узлов в единый реестр (`registry`)
- Комбинирует базовые пути при вложенности
- Использует `baseSpecificity` для выбора наиболее специфичного маршрута при множественных совпадениях
- Строит дерево маршрутов, учитывая `childNode`

#### `getNodeChildren(): NodeChild[]`
Возвращает массив дочерних узлов навигации. Используется для построения иерархической структуры навигации.

**Структура NodeChild:**
```typescript
type NodeChild = {
  prefix: string;                     // Префикс пути для дочернего узла
  node: NavigationNode | NavigationStack;  // Дочерний узел
  onMatch?: () => void;               // Опциональный коллбек при совпадении маршрута
                                      // Используется для обновления внутреннего состояния
                                      // (например, TabBar меняет активную вкладку)
};
```

**Роль Router:**
- Рекурсивно обходит дерево узлов при построении реестра маршрутов
- Комбинирует префиксы для построения полных путей
- Регистрирует `onMatch` коллбеки в `stackActivators` для активации узлов при навигации

#### `getRenderer(): React.ComponentType<any>`
Возвращает React компонент, который должен быть отрендерен для данного узла.

**Роль:**
- Используется, когда узел сам является маршрутом (например, `TabBar` как экран)
- Router не вызывает этот метод напрямую, он используется при рендеринге маршрута с `childNode`

### Опциональные методы

#### `seed?(): { routeId: string; params?: Record<string, unknown>; path: string; stackId?: string } | null`
Вызывается Router при инициализации для получения начального маршрута, если URL не предоставлен (например, в нативных приложениях).

**Роль Router:**
- Вызывается в `seedInitialHistory()` если история пуста
- Используется для создания начальной записи в истории
- Если возвращает `null`, маршрут не добавляется

---

## Как Router использует NavigationNode

### 1. Построение реестра маршрутов (`buildRegistry`)

При инициализации или изменении корневого узла (`setRoot`) Router:

1. **Рекурсивно обходит дерево узлов**, начиная с корневого
2. **Собирает все маршруты** из `getNodeRoutes()` каждого узла
3. **Комбинирует базовые пути** для вложенных маршрутов
4. **Регистрирует дочерние узлы** через `getNodeChildren()`
5. **Строит CompiledRoute** с учетом специфичности и паттернов
6. **Сохраняет связи** между маршрутами и стеками через `stackId`

**Пример процесса:**
```
Root Stack (stack-1)
  ├─ Route: "/" (route-1, childNode: TabBar)
  │   └─ TabBar (tabbar-1)
  │       ├─ Child: Stack A (stack-a)
  │       │   └─ Route: "/home"
  │       └─ Child: Stack B (stack-b)
  │           └─ Route: "/catalog"
  └─ Route: "/auth" (route-2)
      └─ Auth Stack (stack-auth)
          └─ Route: "/auth?kind=email"
```

### 2. Матчинг маршрутов (`matchBaseRoute`)

При навигации Router:

1. **Парсит путь и query** из входного URL
2. **Итерирует по реестру** `CompiledRoute` (построенному из `NodeRoute`)
3. **Проверяет совпадение** через `matchPath()` из `NodeRoute`
4. **Проверяет query-паттерн** через `queryPattern`
5. **Выбирает наиболее специфичный** маршрут на основе `baseSpecificity`
6. **Возвращает CompiledRoute** для дальнейшей обработки

### 3. Управление историей

Router хранит состояние навигации в `history: HistoryItem[]`, где каждый элемент содержит:

- `key` — уникальный ключ записи
- `routeId` — ID маршрута из `NodeRoute`
- `stackId` — ID стека (получен через `getId()` узла)
- `component`, `options`, `params`, `query` — из `NodeRoute` и матчинга
- `path` — текущий путь

**Важно:** Router делегирует определение структуры маршрутов NavigationNode, но сам управляет историей и состоянием навигации.

### 4. Активация узлов

При совпадении маршрута Router:

1. Проверяет наличие `stackActivators` для `stackId`
2. Вызывает `onMatch` коллбек из `NodeChild` (если был зарегистрирован)
3. Это позволяет узлам (например, TabBar) обновлять свое внутреннее состояние

### 5. Получение истории стека

Router предоставляет API для получения истории конкретного стека:

```typescript
router.getStackHistory(stackId?: string): HistoryItem[]
router.subscribeStack(stackId: string, callback: () => void): () => void
```

Это позволяет компонентам (например, `NavigationStack`) подписываться на изменения истории и обновлять UI.

---

## Реализации NavigationNode

### NavigationStack

**Назначение:** Реализует стековую навигацию (LIFO).

**Реализация контракта:**
- `getId()` — возвращает уникальный `stackId`
- `getNodeRoutes()` — возвращает маршруты, добавленные через `addScreen()`, `addModal()`, `addSheet()`
- `getNodeChildren()` — возвращает вложенные стеки, добавленные через `addStack()`
- `getRenderer()` — возвращает заглушку (NavigationStack сам не рендерится)
- `seed()` — возвращает первый маршрут стека для начальной истории

**Дополнительные возможности:**
- `getDefaultOptions()` — опции по умолчанию для всех экранов стека
- Управление специфичностью маршрутов (path + query patterns)
- Поддержка контроллеров для асинхронной навигации

### TabBar

**Назначение:** Реализует таб-бар навигацию (переключение между несколькими стеками).

**Реализация контракта:**
- `getId()` — возвращает уникальный `tabBarId`
- `getNodeRoutes()` — возвращает пустой массив (TabBar сам не является маршрутом)
- `getNodeChildren()` — возвращает стеки из табов с `onMatch` коллбеками для переключения активной вкладки
- `getRenderer()` — возвращает компонент, который рендерит `RenderTabBar`

**Дополнительные возможности:**
- Внутреннее состояние (`index`, `tabs`) для отслеживания активной вкладки
- `onIndexChange()` вызывается через `onMatch` коллбек при навигации
- Управление бейджами через `setBadge()`

**Особенность:** TabBar используется как `childNode` маршрута в NavigationStack, что позволяет ему быть частью иерархии навигации.

---

## Поток работы

### Инициализация

```
1. Создание Router с root: NavigationNode
   ↓
2. Router.buildRegistry()
   ├─ Вызов root.getNodeRoutes()
   ├─ Вызов root.getNodeChildren()
   ├─ Рекурсивный обход дочерних узлов
   └─ Построение CompiledRoute реестра
   ↓
3. seedInitialHistory() или parse(URL)
   ├─ Вызов root.seed?() (если история пуста)
   └─ Создание начальной HistoryItem
   ↓
4. recomputeVisibleRoute()
   └─ Определение текущего видимого маршрута
```

### Навигация

```
1. router.navigate(path) или router.replace(path)
   ↓
2. performNavigation(path, action)
   ├─ parsePath(path) → { pathname, query }
   ├─ matchBaseRoute(pathname, query)
   │   └─ Поиск в registry, проверка matchPath(), queryPattern
   └─ Получение CompiledRoute
   ↓
3. Активация стека (если нужно)
   └─ Вызов stackActivators.get(stackId)?.()
   ↓
4. Обработка контроллера (если есть)
   ├─ controller({ params, query }, present)
   └─ present() → создание HistoryItem
   ↓
5. applyHistoryChange(action, item)
   ├─ Обновление state.history
   ├─ Обновление stackSlices
   ├─ emit для stackListeners
   └─ recomputeVisibleRoute()
   ↓
6. Обновление UI
   └─ Компоненты подписаны на изменения через subscribeStack()
```

### Возврат назад (goBack)

```
1. router.goBack()
   ↓
2. tryPopActiveStack()
   ├─ Определение активного стека (visibleRoute.stackId)
   ├─ Получение top элемента из stackSlices
   ├─ Проверка возможности возврата
   └─ applyHistoryChange('pop', item)
   ↓
3. Обновление истории и UI
```

---

## Ключевые принципы делегирования

### Что делегируется NavigationNode

1. **Структура маршрутов** — какие маршруты существуют и как они матчатся
2. **Иерархия навигации** — какие узлы являются дочерними
3. **Компоненты** — что рендерится для каждого маршрута
4. **Опции экранов** — как выглядят экраны (header, animation)
5. **Начальное состояние** — через `seed()`

### Что управляется Router

1. **История навигации** — последовательность переходов
2. **Текущий маршрут** — `visibleRoute`
3. **Синхронизация URL** — на веб-платформах
4. **Координация навигации** — push, replace, pop операции
5. **Подписки** — уведомления об изменениях

---

## Расширяемость

Любой класс, реализующий `NavigationNode`, может быть использован Router. Это позволяет:

- Создавать кастомные типы навигации (например, Drawer, Accordion)
- Комбинировать разные типы навигации в одном приложении
- Инкапсулировать логику навигации в отдельных узлах

**Пример создания нового типа навигации:**
```typescript
class DrawerNavigation implements NavigationNode {
  getId(): string { /* ... */ }
  getNodeRoutes(): NodeRoute[] { /* ... */ }
  getNodeChildren(): NodeChild[] { /* ... */ }
  getRenderer(): React.ComponentType<any> { /* ... */ }
}
```

Router будет работать с `DrawerNavigation` точно так же, как с `NavigationStack` или `TabBar`.

---

## Резюме

**Router** — это универсальный движок навигации, который:
- Работает **только** с `NavigationNode` (контракт, не конкретные реализации)
- **Делегирует** всю логику определения маршрутов и структуры узлам
- **Управляет** историей навигации и координацией переходов
- **Координирует** работу различных типов навигации (Stack, TabBar, и т.д.)

**NavigationNode** — это контракт, который:
- Определяет **структуру** навигации через маршруты и дочерние узлы
- Предоставляет **компоненты** для рендеринга
- Позволяет узлам **управлять** своим внутренним состоянием
- Обеспечивает **расширяемость** системы навигации
