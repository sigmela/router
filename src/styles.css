.screen-stack {
  min-width: 100%;
  width: 100%;
  display: flex;
  position: relative;
  height: 100dvh;
  overflow: hidden;
}

.screen-stack > .screen-stack-item {
  position: absolute;
  inset: 0;
  font-size: 24px;
  overflow: hidden;
  display: none;
  /* z-index задаётся inline в ScreenStack.web.tsx */

  /* Базовый transition для открытия экрана */
  transition:
    transform 300ms cubic-bezier(0.4, 0.0, 0.2, 1),
    filter 300ms cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* Внутренний контейнер обычного экрана */
.stack-screen-container {
  display: flex;
  flex: 1;
  height: 100%;
}

/* Внутренний контейнер модалки (НЕ flex: 1, чтобы не растягиваться на всю ширину) */
.stack-modal-container {
  display: flex;
  height: 100%;
}

/* Overlay внутри ScreenStackItem — всегда full-screen, только opacity-анимация */
.stack-modal-overlay {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0);
  opacity: 0;
  pointer-events: none;
  z-index: 1;
  will-change: opacity;
}

/* Показываем overlay только для модалок */
.screen-stack-item:not(.modal) .stack-modal-overlay {
  display: none;
}

/* Keyframes для появления overlay */
@keyframes modal-overlay-enter {
  from {
    opacity: 0;
  }
  to {
    opacity: 0.5;
  }
}

/* Keyframes для исчезновения overlay */
@keyframes modal-overlay-exit {
  from {
    opacity: 0.5;
  }
  to {
    opacity: 0;
  }
}

/* Overlay в начальном состоянии — прозрачный */
.screen-stack-item.modal.transition-preEnter .stack-modal-overlay,
.screen-stack-item.modal.transition-preEnter .stack-modal-overlay {
  opacity: 0;
  background: rgba(0, 0, 0, 0.5);
  pointer-events: none;
}

/* Overlay при входе — запускаем анимацию */
.screen-stack-item.modal.transition-entering .stack-modal-overlay,
.screen-stack-item.modal.phase-active.transition-preEnter .stack-modal-overlay,
.screen-stack-item.modal.transition-entering .stack-modal-overlay,
.screen-stack-item.modal.phase-active.transition-preEnter .stack-modal-overlay {
  background: rgba(0, 0, 0, 0.5);
  pointer-events: none;
  animation: modal-overlay-enter 300ms cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
}

/* Для модалок в активных / вошедших состояниях — полностью видимый */
.screen-stack-item.modal.phase-active .stack-modal-overlay,
.screen-stack-item.modal.transition-entered .stack-modal-overlay,
.screen-stack-item.modal.phase-active .stack-modal-overlay,
.screen-stack-item.modal.transition-entered .stack-modal-overlay {
  opacity: 0.5;
  background: rgba(0, 0, 0, 0.5);
  pointer-events: auto;
}

/* Overlay при закрытии модалки — анимация исчезновения */
.screen-stack-item.modal.phase-exiting .stack-modal-overlay,
.screen-stack-item.modal.transition-exiting .stack-modal-overlay,
.screen-stack-item.modal.phase-exiting .stack-modal-overlay,
.screen-stack-item.modal.transition-exiting .stack-modal-overlay {
  background: rgba(0, 0, 0, 0.5);
  pointer-events: none;
  animation: modal-overlay-exit 250ms cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
}

/* Overlay для transparent-modal — прозрачный */
.screen-stack-item.transparent-modal .stack-modal-overlay {
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Overlay для contained-transparent-modal — прозрачный */
.screen-stack-item.contained-transparent-modal .stack-modal-overlay {
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Контейнер контента модалки всегда над overlay */
.screen-stack-item.modal .stack-modal-container,
.screen-stack-item.modal .stack-modal-container {
  position: relative;
  z-index: 2;
}

/* Показываем активные / входящие элементы */
.screen-stack > .screen-stack-item.phase-active,
.screen-stack > .screen-stack-item.transition-entered,
.screen-stack > .screen-stack-item.transition-entering,
.screen-stack > .screen-stack-item.transition-preEnter {
  display: flex;
}

/* Базовое состояние для активных элементов после входа */
/* Переопределяется через классы анимации (push-enter, pop-enter и т.д.) */
.screen-stack > .screen-stack-item.phase-active.transition-entered:not(.push-enter):not(.pop-enter):not(.modal):not(.sheet) {
  transform: translateX(0);
  filter: none;
}

/* Фоновые (inactive) — видимы, но без интеракций */
.screen-stack > .screen-stack-item.phase-inactive {
  display: flex;
  pointer-events: none; /* Не перехватываем клики */
}

/* Выходящие элементы тоже показываем во время анимации */
/* Важно: также показываем элементы с pop-exit, даже если они еще в transition-entered */
.screen-stack > .screen-stack-item.phase-exiting,
.screen-stack > .screen-stack-item.transition-exiting,
.screen-stack > .screen-stack-item.transition-preExit,
.screen-stack > .screen-stack-item.pop-exit {
  display: flex;
}

/* Полностью вышедшие — скрываем */
.screen-stack > .screen-stack-item.transition-exited,
.screen-stack > .screen-stack-item.transition-unmounted {
  display: none;
}

/* ==================== МОДАЛКИ: базовая нейтрализация transform ==================== */

/* ВАЖНО: модальные элементы не должны двигаться как обычные экраны */
.screen-stack > .screen-stack-item.modal,
.screen-stack > .screen-stack-item.sheet {
  transform: translate3d(0, 0, 0) !important;
}

/* ==================== ОБЩИЕ СТИЛИ ПО ТИПУ ЭКРАНА ==================== */

/* Push экраны - базовые стили */
.screen-stack-item.push {
  /* Общие стили для всех push экранов */
}

/* Modal экраны - базовые стили */
.screen-stack-item.modal {
  /* Общие стили для всех modal экранов */
}

/* Sheet экраны - базовые стили */
.screen-stack-item.sheet {
  /* Общие стили для всех sheet экранов */
}

/* ==================== PUSH АНИМАЦИИ ==================== */

/* Forward navigation (push) — открытие экрана 300ms */
.screen-stack-item.push.push-enter {
  transition:
    transform 300ms cubic-bezier(0.4, 0.0, 0.2, 1),
    filter 300ms cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* PUSH ENTER - обычный экран въезжает справа */
.screen-stack-item.push.push-enter.transition-preEnter {
  transform: translateX(100%);
}

.screen-stack-item.push.push-enter.transition-entering,
.screen-stack-item.push.push-enter.transition-entered {
  transform: translateX(0);
}

/* PUSH BACKGROUND - фоновый экран сдвигается влево */
/* Важно: используем !important чтобы перебить общие правила для inactive */
.screen-stack-item.push.push-background {
  transform: translateX(-25%) !important;
  transition:
    transform 300ms cubic-bezier(0.4, 0.0, 0.2, 1),
    filter 300ms cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* POP BACKGROUND - фоновый экран при pop остается на -25% */
/* Фоновые элементы при pop получают pop-background вместо none, чтобы сохранить позицию -25% */
.screen-stack-item.push.pop-background {
  transform: translateX(-25%) !important;
  /* Не устанавливаем transition, чтобы элемент оставался на месте без анимации */
  filter: none;
}

/* Backward navigation (pop) — закрытие экрана 250ms */
/* ВАЖНО: transition устанавливается на элементе с pop-exit */
.screen-stack-item.push.pop-exit {
  transition:
    transform 250ms cubic-bezier(0.4, 0.0, 0.2, 1),
    filter 250ms cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* POP EXIT - верхний экран уезжает вправо */
/* Ключевое отличие от старой версии: в старой селектор .phase-exiting применялся БЕЗ зависимости от transition-exiting */
/* Здесь мы делаем то же самое: если элемент имеет pop-exit и phase-exiting, он должен уехать вправо */
.screen-stack-item.push.pop-exit.phase-exiting,
.screen-stack-item.push.pop-exit.transition-exiting {
  transform: translateX(100%);
  filter: none;
}

/* POP ENTER - экран возвращается в центр из -25% */
/* Применяется только к активному (top) элементу при pop */
/* В старой версии: элемент был на -25% (как фоновый), затем при pop становится active и идет в 0 */
/* Упрощенный подход как в старой версии: phase-active просто становится в 0 */
.screen-stack-item.push.pop-enter {
  transition:
    transform 250ms cubic-bezier(0.4, 0.0, 0.2, 1),
    filter 250ms cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* Активный элемент при pop просто в центре (0) - финальное состояние */
/* Как в старой версии: .phase-active при pop → transform: translateX(0) */
.screen-stack-item.push.pop-enter.phase-active,
.screen-stack-item.push.pop-enter.phase-active.transition-entered {
  transform: translateX(0);
  filter: none;
}

/* ==================== МОДАЛЬНЫЙ СТЕК: фон не двигаем ==================== */

/* Если сверху есть модалка — не двигаем предыдущий экран и не затемняем его,
   за затемнение отвечает overlay. */
.screen-stack:has(> .screen-stack-item.modal.phase-active)
  > .screen-stack-item.push.phase-inactive,
.screen-stack:has(> .screen-stack-item.modal.phase-active)
  > .screen-stack-item.push.phase-inactive.transition-entered {
  transform: translate3d(0, 0, 0) !important;
  filter: none;
}

/* ==================== MOBILE MODAL (<= 639px) — bottom sheet ==================== */
@media (max-width: 639px) {
  /* Overlay для мобильной модалки — прозрачный */
  .screen-stack-item.modal .stack-modal-overlay {
    opacity: 0 !important;
    pointer-events: none !important;
  }

  /* Внутренний контейнер модалки — bottom sheet на всю ширину без скругления */
  .screen-stack-item.modal .stack-modal-container {
    width: 100%;
    margin: 0;
    border-radius: 0;
    align-self: flex-end; /* прижимаем к нижнему краю родителя */
    overflow: hidden;
    background: #fff; /* или var(--modal-bg) */

    transform: translateY(0);
    transition:
      transform 300ms cubic-bezier(0.4, 0.0, 0.2, 1),
      filter 300ms cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  /* MODAL ENTER - модалка входит (снизу вверх) */
  .screen-stack-item.modal.modal-enter.transition-preEnter .stack-modal-container {
    transform: translateY(100%);
    filter: none;
  }

  .screen-stack-item.modal.modal-enter.transition-entering .stack-modal-container,
  .screen-stack-item.modal.modal-enter.transition-entered .stack-modal-container {
    transform: translateY(0);
    filter: none;
  }

  /* MODAL EXIT - модалка закрывается (уезжает вниз) */
  .screen-stack-item.modal.modal-exit.transition-exiting .stack-modal-container {
    transform: translateY(100%);
    filter: none;
    transition:
      transform 250ms cubic-bezier(0.4, 0.0, 0.2, 1),
      filter 250ms cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  /* SHEET ENTER - sheet входит (снизу вверх) */
  .screen-stack-item.sheet.sheet-enter.transition-preEnter .stack-modal-container {
    transform: translateY(100%);
    filter: none;
  }

  .screen-stack-item.sheet.sheet-enter.transition-entering .stack-modal-container,
  .screen-stack-item.sheet.sheet-enter.transition-entered .stack-modal-container {
    transform: translateY(0);
    filter: none;
  }

  /* SHEET EXIT - sheet закрывается */
  .screen-stack-item.sheet.sheet-exit.transition-exiting .stack-modal-container {
    transform: translateY(100%);
    filter: none;
    transition:
      transform 250ms cubic-bezier(0.4, 0.0, 0.2, 1),
      filter 250ms cubic-bezier(0.4, 0.0, 0.2, 1);
  }
}

/* ==================== DESKTOP MODAL (>= 640px) — sheet справа ==================== */
@media (min-width: 640px) {
  /* Внутренний контейнер модалки — правый sheet 393px, с margin и скруглением */
  .screen-stack-item.modal .stack-modal-container {
    width: 393px;
    max-width: calc(100% - 36px);
    height: calc(100% - 36px);
    margin: 18px;
    margin-left: auto; /* прижимаем к правому краю */
    border-radius: 16px;
    overflow: hidden;
    background: #fff; /* или var(--modal-bg) */

    transform: translateX(0);
    transition:
      transform 300ms cubic-bezier(0.4, 0.0, 0.2, 1),
      filter 300ms cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  /* MODAL ENTER - модалка входит (справа налево) */
  .screen-stack-item.modal.modal-enter.transition-preEnter .stack-modal-container {
    transform: translateX(100%);
    filter: none;
  }

  .screen-stack-item.modal.modal-enter.transition-entering .stack-modal-container,
  .screen-stack-item.modal.modal-enter.transition-entered .stack-modal-container {
    transform: translateX(0);
    filter: none;
  }

  /* MODAL EXIT - модалка закрывается (уезжает вправо) */
  .screen-stack-item.modal.modal-exit.transition-exiting .stack-modal-container {
    transform: translateX(100%);
    filter: none;
    transition:
      transform 250ms cubic-bezier(0.4, 0.0, 0.2, 1),
      filter 250ms cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  /* SHEET ENTER - sheet входит (справа налево) */
  .screen-stack-item.sheet.sheet-enter.transition-preEnter
    .stack-modal-container {
    transform: translateX(100%);
    filter: none;
  }

  .screen-stack-item.sheet.sheet-enter.transition-entering
    .stack-modal-container,
  .screen-stack-item.sheet.sheet-enter.transition-entered
    .stack-modal-container {
    transform: translateX(0);
    filter: none;
  }

  /* SHEET EXIT - sheet закрывается */
  .screen-stack-item.sheet.sheet-exit.transition-exiting
    .stack-modal-container {
    transform: translateX(100%);
    filter: none;
    transition:
      transform 250ms cubic-bezier(0.4, 0.0, 0.2, 1),
      filter 250ms cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  /* Фоновые экраны под модалкой — не двигаем, не затемняем (overlay делает это) */
  .screen-stack:has(> .screen-stack-item.modal.phase-active)
    > .screen-stack-item.push.phase-inactive,
  .screen-stack:has(> .screen-stack-item.modal.phase-active)
    > .screen-stack-item.push.phase-inactive.transition-entered {
    transform: translate3d(0, 0, 0) !important;
    filter: none;
  }
}

/* ==================== INACTIVE SCREENS (общие настройки) ==================== */

/* Inactive screens (фоновые элементы стека)
   Фоновые элементы при pop получают animationType: pop-background и остаются на -25%
   (кроме случая с модалкой, там переопределяем через :has) */
.screen-stack > .screen-stack-item.phase-inactive:not(.push-background):not(.pop-background):not(.pop-enter):not(.pop-exit):not(.modal):not(.sheet) {
  /* Не устанавливаем transform явно - элемент сохранит предыдущую позицию */
  filter: none;
}

/* ==================== СПЕЦИАЛЬНЫЕ СЛУЧАИ ==================== */

/* NO-ANIMATE - без анимации (screenOptions.animated === false) */
/* ВАЖНО: это правило должно перебивать все остальные правила анимации */
.screen-stack-item.no-animate,
.screen-stack-item.no-animate.push-enter,
.screen-stack-item.no-animate.push-exit,
.screen-stack-item.no-animate.push-background,
.screen-stack-item.no-animate.pop-enter,
.screen-stack-item.no-animate.pop-exit,
.screen-stack-item.no-animate.pop-background {
  transform: translate3d(0, 0, 0) !important;
  transition: none !important;
  filter: none !important;
}

/* NONE - без анимации (initial mount) */
/* ВАЖНО: это правило НЕ должно применяться к pop-background элементам */
.screen-stack-item.none:not(.pop-background) {
  transform: translate3d(0, 0, 0) !important;
  transition: none !important;
  filter: none !important;
}



.tab-stacks-container {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  min-height: 100dvh;
}

.tab-bar {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  position: relative;
  height: 49px;
}

.tab-item {
  appearance: none;
  background: transparent;
  border: 0;
  margin: 0;
  padding: 4px 0 2px;
  height: 100%;
  color: inherit;
  display: flex;
  flex: 1 1 0%;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  cursor: pointer;
}

.tab-item:focus {
  outline: none;
}

.tab-item-icon {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tab-item-icon > * {
  width: 24px;
  height: 24px;
  display: block;
  object-fit: contain;
}

.tab-item-label {
  font-size: 11px;
  line-height: 12px;
  text-align: center;
  white-space: nowrap;
  pointer-events: none;
  margin-top: 2px;
}

.tab-item-label-badge {
  position: absolute;
  top: 4px;
  left: 50%;
  transform: translateX(10px);
  min-width: 16px;
  height: 16px;
  padding: 0 5px;
  border-radius: 9999px;
  background-color: #dc3545;
  color: #fff;
  font-size: 10px;
  line-height: 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

/* ==================== SPLIT VIEW (web) ==================== */

.split-view-container {
  position: relative;
  display: block; /* narrow by default; wide enabled via injected @media rule */
  height: 100dvh;
  min-height: 100dvh;
  width: 100%;
  overflow: hidden;
}

.split-view-container .screen-stack {
  /* ScreenStack has min-width: 100%, which breaks side-by-side layouts */
  min-width: 0;
}

.split-view-primary {
  position: relative;
  width: 100%;
  height: 100%;
  min-width: 0;
}

.split-view-secondary {
  position: absolute;
  inset: 0;
  z-index: 2;
  width: 100%;
  height: 100%;
  min-width: 0;
}

/* In narrow mode, hide secondary completely if it has no active screen */
.split-view-secondary:not(:has(.screen-stack-item.phase-active)):not(:has(.screen-stack-item.phase-exiting)):not(:has(.screen-stack-item.transition-entering)):not(:has(.screen-stack-item.transition-entered)):not(:has(.screen-stack-item.transition-preEnter)):not(:has(.screen-stack-item.transition-exiting)):not(:has(.screen-stack-item.transition-preExit)):not(:has(.screen-stack-item.pop-exit)) {
  display: none;
}

.split-view-container:has(.split-view-secondary:has(.screen-stack-item.phase-active)) .split-view-primary,
.split-view-container:has(.split-view-secondary:has(.screen-stack-item.phase-exiting)) .split-view-primary,
.split-view-container:has(.split-view-secondary:has(.screen-stack-item.transition-entering)) .split-view-primary,
.split-view-container:has(.split-view-secondary:has(.screen-stack-item.transition-entered)) .split-view-primary,
.split-view-container:has(.split-view-secondary:has(.screen-stack-item.transition-preEnter)) .split-view-primary,
.split-view-container:has(.split-view-secondary:has(.screen-stack-item.transition-exiting)) .split-view-primary,
.split-view-container:has(.split-view-secondary:has(.screen-stack-item.transition-preExit)) .split-view-primary,
.split-view-container:has(.split-view-secondary:has(.screen-stack-item.pop-exit)) .split-view-primary {
  pointer-events: none;
}
